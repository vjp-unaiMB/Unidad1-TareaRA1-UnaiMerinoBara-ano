{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Actividad obligatoria Unidad 1 - Tarea RA1","text":"<p>Autor: <code>Unai Merino Bara\u00f1ano</code></p>"},{"location":"#indice","title":"\u00cdndice","text":"<p>Elementos de Python</p> <p>Ejecuci\u00f3n y Depuraci\u00f3n</p> <p>Ejecuci\u00f3n en Sandbox</p> <p>Comparaci\u00f3n estructural de los lenguajes m\u00e1s famosos.</p>"},{"location":"#objetivos","title":"Objetivos","text":"<ul> <li> <p>Analizar y comprender la estructura interna del c\u00f3digo (clases, m\u00e9todos, flujos de control) y su modelo de ejecuci\u00f3n (transiciones de estado y manejo de excepciones) para determinar los puntos cr\u00edticos de prueba.</p> </li> <li> <p>Aplicar las herramientas del IDE (Integrated Development Environment) para la ejecuci\u00f3n, depuraci\u00f3n paso a paso y seguimiento del flujo de control, identificando y resolviendo posibles errores l\u00f3gicos o de sintaxis.</p> </li> <li> <p>Dise\u00f1ar, implementar y ejecutar pruebas unitarias que cubran la totalidad de los requisitos funcionales y no funcionales, validando la l\u00f3gica individual de cada componente del c\u00f3digo.</p> </li> <li> <p>Verificar que la aplicaci\u00f3n maneja correctamente las reglas de negocio (precios, transiciones de fase y gesti\u00f3n de estados de error), tal como se define en la documentaci\u00f3n.</p> </li> <li> <p>Ejecutar la aplicaci\u00f3n en un entorno controlado para simular su comportamiento en un contexto real, validando la interacci\u00f3n entre sus componentes y el entorno de runtime.</p> </li> </ul>"},{"location":"#apartados","title":"Apartados","text":""},{"location":"#elementos-de-python","title":"Elementos de Python","text":"<p>Explicaci\u00f3n del funcionamiento y elementos del c\u00f3digo \u279c Ir</p>"},{"location":"#ejecucion-y-depuracion","title":"Ejecuci\u00f3n y Depuraci\u00f3n","text":"<p>Prueba de ejecuci\u00f3n del programa \u279c Ir</p>"},{"location":"#pruebas","title":"Pruebas","text":"<p>Depuraci\u00f3n del c\u00f3digo y captura de e \u279c Ir</p>"},{"location":"#ejecucion-en-sandbox","title":"Ejecuci\u00f3n en Sandbox","text":"<p>Gu\u00eda de ejecuci\u00f3n del programa lavadero en un entorno aislado \u279c Ir</p>"},{"location":"#comparacion-estructural-de-los-lenguajes-mas-famosos","title":"Comparaci\u00f3n estructural de los lenguajes m\u00e1s famosos.","text":"<p>Reflexi\u00f3nes sobre la arquitectura de los lenguajes y su seguridad \u279c Ir</p>"},{"location":"ComparacionEstructuralDeLenguajesFamosos/","title":"Comparaci\u00f3n estructural de los lenguajes m\u00e1s famosos.","text":"<p>En este apartado comparar\u00e9 algunos de los lenguajes de programaci\u00f3n m\u00e1s populares y con distintos usos. Poniendo en valor la seguridad que ofrecen mediante un breve resumen.</p> Lenguaje Tipo de Ejecuci\u00f3n Paradigma Principal Seguridad de Memoria \u200b Java Compilado  \u200b Orientado a Objetos \u200b Alta gracias a sandbox y garbage collector que a\u00edslan c\u00f3digo y evitan fugas de memoria. Python Interpretado \u200b Multiparadigma \u200b Media con tipado din\u00e1mico permite inyecciones si no se valida input correctamente. Rust Compilado  \u200b Multiparadigma (sistemas) \u200b Muy alta por ownership y borrow checker que previene race conditions y accesos inv\u00e1lidos. C++ Compilado  \u200b Multiparadigma  \u200b Baja por su gesti\u00f3n manual propensa a buffer overflows y errores de punteros. PHP Interpretado \u200b Multiparadigma (web, procedural) \u200b Media-baja, es vulnerable a SQL injection sin sanitizaci\u00f3n adecuada de entradas. JavaScript Interpretado (JIT en navegadores) \u200b Multiparadigma\u200b Media,gracias a que el sandbox del navegador mitiga, pero el XSS es com\u00fan por manipulaci\u00f3n DOM insegura. C Compilado nativo \u200b Procedural/imperativo \u200b Muy baja, los punteros y memoria manual causan exploits frecuentes como overflows."},{"location":"ComparacionEstructuralDeLenguajesFamosos/#conclusiones","title":"Conclusiones","text":"<ul> <li> <p>Considero que de base los lenguajes compilados son m\u00e1s seguros que los interpretados, debido a que cuando debes de compilar el c\u00f3digo, dicho proceso de traducci\u00f3n obliga al usuario a implementar el c\u00f3digo correctamente antes de su ejecuci\u00f3n, lo que asegura que la estructura del c\u00f3digo es \u00f3ptima.</p> </li> <li> <p>Los 2 lenguajes m\u00e1s seguros de la tabla son Java y Rust, sus estructuras son las m\u00e1s s\u00f3lidas, asegurando que cualquier error sea controlable, por otra parte C y C++ requieren disciplina extrema debido a su bajo nivel. </p> </li> <li> <p>Rust es el m\u00e1s s\u00f3lido y seguro de todos al ser compilado y ser de bajo nivel, no obstante tiene abstracciones seguras que lo acercan a caracter\u00edsticas de alto nivel, lo que lo hace m\u00e1s f\u00e1cil de trabajar y familiar que el resto de lenguajes de su categor\u00eda.</p> </li> </ul>"},{"location":"EjecucionEnSandbox/","title":"Ejecuci\u00f3n en Sandbox","text":""},{"location":"EjecucionEnSandbox/#paso-1-empezaremos-instalando-la-herramienta-de-sandbox-firejail","title":"Paso 1 : Empezaremos instalando la herramienta de SANDBOX (Firejail).","text":"<p>Usaremos el comandoo <code>apt update &amp;&amp; apt install -y firejail firetools</code> en un terminal con privilegios de administrador.</p> <p></p>"},{"location":"EjecucionEnSandbox/#paso-2-obtenemos-nuestro-programa-a-analizar-lavaderopy","title":"Paso 2 : Obtenemos nuestro programa a analizar (Lavadero.py)","text":"<p>Para ello, he descargado el programa del enlace de la actividad 1 de este RA y la he ubidado en el escritorio de Kali, dentro de la carpeta src</p> <p></p> <p>Compruebo que funciona a la perfecci\u00f3n antes de realizar nada(Como es un programa orientado a objetos con m\u00faltiples dependencias, ejecutamos el main), yo como ya tengo Python3 instalad0o no tengo que instalar nada adicional.</p> <p></p>"},{"location":"EjecucionEnSandbox/#paso-3-ejecutamos-el-programa-bajo-el-entorno-sandbox-firejail","title":"Paso 3 : Ejecutamos el programa bajo el entorno SANDBOX (Firejail)","text":"<p>La importancia de aislar empleempleando un entorno sandbox en vez de ejecutar nuestro programa directamente en el terminal del sistema es aislarlo para evitar que este pueda alterar o afectar al dispositivo, a parte de convertirlo en una prueba m\u00e1s controlada. En este caso es un prpgrama peque\u00f1o que no supone ning\u00fan riesgo pero si se estuviera desarrollando un programa que manipula informaci\u00f3n del equipo si.</p> <p>Lo lanzaremos en el entorno aislado mediante el comando: <code>firejail python3 /home/PPSUnai/Desktop/src/src/main_app.py</code></p> <p></p>"},{"location":"EjecucionEnSandbox/#resultado-final","title":"Resultado final.","text":"<p>En este programa, se declaran 4 instancias de simulaciones, en las que se probar\u00e1 el objeto lavadero con distintos par\u00e1metros, propiciando casos particulares. Se ejecutan a la perfecci\u00f3n:</p> <p>Prueba 1: </p> <p>Prueba 2: </p> <p>Prueba 3: </p> <p>Prueba 4: </p>"},{"location":"EjecucionYDepuracion/","title":"Ejecuci\u00f3n y depuraci\u00f3n","text":"<p>Una vez visto el apartado en el que explicamos el funcionamiento del programa Lavadero, vamos a hacer una prueba de interpretaci\u00f3n del lenguaje. </p> <p>Para ello nos dirigiremos hacia un terminal con privilegios de administrador. tenemos que cerciorarnos de teneir instalado Python 3 en nuestra m\u00e1quina, porque si de lo contrario no podremos ejecutar el programa.</p>"},{"location":"EjecucionYDepuracion/#comprobar-que-tenemos-python-instalado","title":"Comprobar que tenemos Python instalado","text":"<p>Para ver si lo tenemos en nuestra m\u00e1quina ejecutamos:</p> <pre><code>bash\npython3 --version\n</code></pre> <p></p>"},{"location":"EjecucionYDepuracion/#dirigirse-a-la-carpeta-donde-se-encuentra-el-fichero","title":"Dirigirse a la carpeta donde se encuentra el fichero","text":"<p>Ejecutar un <code>.py</code> con python3 Ir a la carpeta donde est\u00e1 el script:</p> <pre><code>bash\ncd /home/PPSUnai/Desktop/src/src/\n</code></pre> <p></p>"},{"location":"EjecucionYDepuracion/#ejecutar-el-fichero-principal","title":"Ejecutar el fichero principal:","text":"<p>Es importante para este punto recordar que el inicio de la ejecuci\u00f3n se produce en <code>Main</code>, por lo que ejecutaremos el fichero Main y no la clase <code>Lavadero</code>.</p> <pre><code>bash\npython3 main_app.py\n</code></pre> <p>Se ejecuta sin problemas, este es un peque\u00f1o vistazo a la ejecuci\u00f3n del c\u00f3digo.</p> <p></p>"},{"location":"EjecucionYDepuracion/#deteccion-de-error-y-solucion","title":"Detecci\u00f3n de error y soluci\u00f3n","text":"<p>Como podemos observar, al final de la ejecuci\u00f3n nos avisa sobre un error de interpretaci\u00f3n emergente.</p> <p></p> <p>Si nos fijamos bien, nos indica el tipo de error que es y donde se encuentra, en erte caso se trata de un error por ausencia de un par\u00e1metro pedido al ejecutar la prueba 4, es m\u00e1s nos dice hasta el par\u00e1metro que es \u00e8ncerado`. </p> <p>Hay que fijarse bien en el tipo de variable antes de hacer nada. En este caso es un Booleano :TypeError: ejecutarSimulacion() missing 1 required positional argument 'encerado'</p> <p>Para corregirlo, solamente nos dirigimos a la l\u00ednea de c\u00f3digo en la que salta y agregamos el par\u00e1metro al final.</p> <p></p> <p>Tras agregar:</p> <pre><code>ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, **encerado=True**)\n</code></pre> <p>Volveremos al terminal y ejecutamos el comando <code>python3 main_app.py</code> de nuevo, esta vez, el no nos saltar\u00e1 ning\u00fan problema de interpretaci\u00f3n, finalizando sin problemas la ejecuci\u00f3n de las 4 pruebas programadas.</p> <p></p>"},{"location":"ElementosDePython/","title":"Elementos de Python","text":"<p>Dentro de este apartado explicaremos el funcionamiento del programa Lavadero analizando las estructuras que lo componen.</p>"},{"location":"ElementosDePython/#caracteristicas-importantes-del-programa","title":"Caracter\u00edsticas importantes del programa.","text":"<p>Ideas Claras</p> <ul> <li> <p>La primera caracter\u00edstica y la m\u00e1s importante es que este programa ha sido elaborado en el lenguaje de programaci\u00f3n Python</p> </li> <li> <p>Emplea el paradigma de programaci\u00f3n orientado a objetos. Este paradigma de programaci\u00f3n consiste en la creaci\u00f3n de objetos mediante clases. Dentro de estas clases, se estructuran los atributos y caracter\u00edsticas que queremos que contengan nuestros objetos a la hora de ser creados, lo que nos lleva a analizar su estructuraci\u00f3n.</p> </li> <li> <p>La estructura de este programa se compone de dos archivos, </p> <ol> <li> <p>El primero de ellos se llama main, es el fichero principal y donde compienza la ejecuci\u00f3n del programa, por lo que deducimos que es donde se van a crear los objetos y otros bloques de c\u00f3digo que interactuar\u00e1n con los objetos.</p> </li> <li> <p>El segundo fichero es la clase lavadero. Dentro de esta clase se declaran las constantes y variables que conformar\u00e1n las caracter\u00edsticas de las que dispondr\u00e1 el objeto lavadero. La clase tambi\u00e9n est\u00e1 conformada por otras estructuras que se encargan de que dichas variables sean manipulables. Aqu\u00ed es donde entran:</p> <ul> <li>Constructores: Estas estructuras se encargan de agrupar los par\u00e1metros introducidos durante la creaci\u00f3n de un bobjeto lavadero y aplicar cada valor a la propiedad correspondiente del objeto.</li> </ul> </li> <li> <p>@property's  Estos elementos se encargan de devolver el valor de un atribuo de un objeto en caso de llamada.</p> </li> <li> <p>M\u00e9todos internos Nos servir\u00e1n para realizar algoridmos internos y automatizar caracter\u00edsticas y comportamientos del objeto en base a nuestros par\u00e1metros.</p> </li> </ol> </li> </ul>"},{"location":"ElementosDePython/#analisis-del-codigo","title":"An\u00e1lisis del c\u00f3digo","text":"<p>Desglosaremos cada uno de los archivos que conforman Lavadero.</p>"},{"location":"ElementosDePython/#mainpy","title":"Main.py","text":"<p>Encabezamos el fichero importando la clase lavadero.</p> <pre><code>from lavadero import Lavadero\n</code></pre> <p>Este m\u00e9todo encarga de simular el proceso de lavado para un veh\u00edculo con las opciones dadas introduciendo los siguientes par\u00e1metros: * <code>lavadero</code>: Instancia de Lavadero. * <code>prelavado</code>: bool, True si se solicita prelavado a mano. * <code>secado_mano</code>: bool, True si se solicita secado a mano. * <code>encerado</code>: bool, True si se solicita encerado.</p> <p>Tras ello, pinta por pantalla las opciones introducidas y anuncia el inicio de la simulaci\u00f3n. Tambi\u00e9n captura excepciones mediante la estructura <code>Try</code></p> <p>Al comenzar la simulaci\u00f3n pasa el valor de las fases a 0 Imprime el estado de cada prueba y avanza fase por fase hasta llegar al final, imprimiendo la informaci\u00f3n en cada parte.</p> <pre><code>def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado):\n\n    print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\")\n    print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\")\n\n    # 1. Iniciar el lavado\n    try:\n        lavadero.hacerLavado(prelavado, secado_mano, encerado)\n        lavadero.imprimir_estado()\n\n        print(\"\\nAVANZANDO FASE POR FASE:\")\n\n        pasos = 0\n        while lavadero.ocupado and pasos &lt; 20: \n            # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -&gt; 1)\n            lavadero.avanzarFase()\n            print(f\"-&gt; Fase actual: \", end=\"\")\n            lavadero.imprimir_fase()\n            print() \n            pasos += 1\n\n        print(\"\\n----------------------------------------\")\n        print(\"Lavado completo. Estado final:\")\n        lavadero.imprimir_estado()\n        print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\")\n        print(\"----------------------------------------\")\n\n    except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2)\n        print(f\"ERROR DE ARGUMENTO: {e}\")\n    except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3)\n        print(f\"ERROR DE ESTADO: {e}\")\n    except Exception as e:\n        print(f\"ERROR INESPERADO: {e}\")\n</code></pre> <p>En este punto del c\u00f3digo, tras los m\u00e9todos vistos, encontramos el lugar desde donde empezar\u00e1 a ejecutarse el c\u00f3digo. Tras este comentario, si el fichero es main, crear\u00e1 una instancia del lavadero sin concretar ning\u00fan par\u00e1metro. Tras ello, se llamar\u00e1 al m\u00e9todo <code>ejecutarSimulacion()</code> aqu\u00ed ser\u00e1 donde introduciremos por par\u00e1metro la instanca y sus caracter\u00edsticas principales. Seg\u00fan lo que introduzcamos, <code>ejecutarSimulacion()</code> a\u00f1adir\u00e1 los valores a\u00f1adidos de cada complemento, dejando un formato resultante que nos permitir\u00e1 comparar cada prueba. Disponiendo de 4 ejemplos. </p> <p>En este caso nos encontramos con el EJEMPLO 1:</p> <pre><code># Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros\nif __name__ == \"__main__\":\n\n    lavadero_global = Lavadero() \n\n    # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14)\n    # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac\n    print(\"\\n=======================================================\")\n    print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\")\n    ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True)\n</code></pre> <p>EJEMPLO 2: Lavado r\u00e1pido sin extras (Precio esperado: 5.00 \u20ac)</p> <pre><code>    print(\"\\n=======================================================\")\n    print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\")\n    ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False)\n</code></pre> <p>EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2)</p> <pre><code>    print(\"\\n=======================================================\")\n    print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\")\n    ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True)\n</code></pre> <p>EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) Precio esperado: 5.00 + 1.50 = 6.50 \u20ac</p> <pre><code>    print(\"\\n=======================================================\")\n    print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\")\n    ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False)\n</code></pre>"},{"location":"ElementosDePython/#lavaderopy","title":"Lavadero.py","text":"<p>Como coment\u00e9 anteriormente, esta fichero es donde se declara la estructura de un objeto, como si fuera un molde. Como nuestro programa emula el funcionamiento de un lavadero, esta clase es indispensable para poder crear dicho objeto. </p> <p>Vamos a analiar la clase lavadero.</p> <pre><code># lavadero.py\n\nclass Lavadero:\n\n    FASE_INACTIVO = 0\n    FASE_COBRANDO = 1\n    FASE_PRELAVADO_MANO = 2\n    FASE_ECHANDO_AGUA = 3\n    FASE_ENJABONANDO = 4\n    FASE_RODILLOS = 5\n    FASE_SECADO_AUTOMATICO = 6\n    FASE_SECADO_MANO = 7\n    FASE_ENCERADO = 8\n\n</code></pre> <p>Justo debajo contamos con un un constructor de la clase un constructor no es m\u00e1s que una estructura que se encarga de inicializar el objeto lavadero, a\u00f1adiendo una serie de valores predeterminados a sus variables. A dem\u00e1s, tambi\u00e9n puede invocar m\u00e9todos, como es el caso de la \u00faltima sentencia <code>self.terminar()</code></p> <pre><code>def __init__(self):\n        self.__ingresos = 0.0\n        self.__fase = self.FASE_INACTIVO\n        self.__ocupado = False\n        self.__prelavado_a_mano = False\n        self.__secado_a_mano = False\n        self.__encerado = False\n        self.terminar() \n\n</code></pre> <p>Las estructuras que contienen el decorador @property son convertidas en un m\u00e9todo de solo lectura, permitiendo acceder a atributos privados de forma directa mediante objeto. Cada uno de estos m\u00e9todos, nos devolver\u00e1 el valor de cada propiedad del objeto al ser invocada.</p> <p>En este caso:</p> <ul> <li>Fase</li> <li>Ingresos (Num\u00e9rico)</li> <li>Ocupado (Booleano)</li> <li>prelavado_a_mano (Booleano)</li> <li>Secado_a_mano (Booleano)</li> <li>Encerado (Booleano)</li> </ul> <pre><code>\n    @property\n    def fase(self):\n        return self.__fase\n\n    @property\n    def ingresos(self):\n        return self.__ingresos\n\n    @property\n    def ocupado(self):\n        return self.__ocupado\n\n    @property\n    def prelavado_a_mano(self):\n        return self.__prelavado_a_mano\n\n    @property\n    def secado_a_mano(self):\n        return self.__secado_a_mano\n\n    @property\n    def encerado(self):\n        return self.__encerado\n</code></pre> <p>Este m\u00e9odo terminar se encarga de poner los valores de las variables del objeto (fase,ocupado,prelavado_a_mano,secado_a_mano y encerado) a false.</p> <pre><code>\n    def terminar(self):\n        self.__fase = self.FASE_INACTIVO\n        self.__ocupado = False\n        self.__prelavado_a_mano = False\n        self.__secado_a_mano = False\n        self.__encerado = False\n\n</code></pre> <p>Este m\u00e9odo hacerLavado se encarga de dar feedback al usuario sobre el lavadero. Controla los valores de las variables del objeto (ocupado,secado_a_mano y encerado mediante una estructura de if e if not, de tamlanera que si el lavadero est\u00e1 ocupado, le advertir\u00e1 al usuario que no puede ocuparlo haste que se libere. Si se puede entrar, cambiar\u00e1 de valor las variables del lavadero a las indicadas y avisar\u00e1 sobre el encerado manual.</p> <pre><code>\n\n    def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado):\n        if self.__ocupado:\n            raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\")\n\n        if not secado_a_mano and encerado:\n            raise ValueError(\"No se puede encerar el coche sin secado a mano\")\n\n        self.__fase = self.FASE_INACTIVO  \n        self.__ocupado = True\n        self.__prelavado_a_mano = prelavado_a_mano\n        self.__secado_a_mano = secado_a_mano\n        self.__encerado = encerado\n\n</code></pre> <p>Este m\u00e9odo cobrar se encarga de calcular y a\u00f1adir los ingresos seg\u00fan las opciones seleccionadas de lavado. Se fija un precio base: 5.00\u20ac y va a\u00f1adiendo un incremento seg\u00fan los extras a\u00f1adidos, se controla mediane varias estructuras IF. Finalmente, retorna el valor del ingreso total con el Return.</p> <pre><code>\n    def _cobrar(self):\n        \"\"\"\n         (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac)\n        \"\"\"\n        coste_lavado = 5.00\n\n        if self.__prelavado_a_mano:\n            coste_lavado += 1.50 \n\n        if self.__secado_a_mano:\n            coste_lavado += 1.20 \n\n        if self.__encerado:\n            coste_lavado += 1.00 \n\n        self.__ingresos += coste_lavado\n        return coste_lavado\n</code></pre> <p>Este m\u00e9todo avanzarFase nos permite cambiar la fase seg\u00fan la fase en la que nos encontramos, est\u00e1 compuesto por una estructura de ifs que controlan la dase en la que se encuentra el usuario y seg\u00fan en la que se encuentre realiza una funci\u00f3n distinta. En algunas de estas fases, ejecuta invocaciones a otros m\u00e9todos y reproduce mensajes.</p> <pre><code>def avanzarFase(self):\n\n        if not self.__ocupado:\n            return\n\n        if self.__fase == self.FASE_INACTIVO:\n            coste_cobrado = self._cobrar()\n            self.__fase = self.FASE_COBRANDO\n            print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\")\n\n        elif self.__fase == self.FASE_COBRANDO:\n            if self.__prelavado_a_mano:\n                self.__fase = self.FASE_PRELAVADO_MANO\n            else:\n                self.__fase = self.FASE_ECHANDO_AGUA \n\n        elif self.__fase == self.FASE_PRELAVADO_MANO:\n            self.__fase = self.FASE_ECHANDO_AGUA\n\n        elif self.__fase == self.FASE_ECHANDO_AGUA:\n            self.__fase = self.FASE_ENJABONANDO\n\n        elif self.__fase == self.FASE_ENJABONANDO:\n            self.__fase = self.FASE_RODILLOS\n\n        elif self.__fase == self.FASE_RODILLOS:\n            if self.__secado_a_mano:\n                self.__fase = self.FASE_SECADO_AUTOMATICO \n\n            else:\n                self.__fase = self.FASE_SECADO_MANO\n\n        elif self.__fase == self.FASE_SECADO_AUTOMATICO:\n            self.terminar()\n\n        elif self.__fase == self.FASE_SECADO_MANO:\n\n            self.terminar() \n\n        elif self.__fase == self.FASE_ENCERADO:\n            self.terminar() \n\n        else:\n            raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\")\n\n</code></pre> <p>Este m\u00e9todo imprimir fase Se invoca junto a un par\u00e1metro num\u00e9rico. Genera un mapa de frases que controlaremos mediante el par\u00e1metro introducido, al final del m\u00e9todo se hace un print en el que se invoca el mala de frases pasando directamente el par\u00e1metro.</p> <pre><code>\n    def imprimir_fase(self):\n        fases_map = {\n            self.FASE_INACTIVO: \"0 - Inactivo\",\n            self.FASE_COBRANDO: \"1 - Cobrando\",\n            self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\",\n            self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\",\n            self.FASE_ENJABONANDO: \"4 - Enjabonando\",\n            self.FASE_RODILLOS: \"5 - Pasando rodillos\",\n            self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\",\n            self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\",\n            self.FASE_ENCERADO: \"8 - Encerando a mano\",\n        }\n        print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\")\n\n\n</code></pre> <p>Este m\u00e9todo imprimir_estado Se invoca junto a un par\u00e1metro num\u00e9rico. Imprime una serie de sentencias en las que se informa del estado de lavado al usuario.</p> <pre><code>def imprimir_estado(self):\n        print(\"----------------------------------------\")\n        print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\")\n        print(f\"Ocupado: {self.ocupado}\")\n        print(f\"Prelavado a mano: {self.prelavado_a_mano}\")\n        print(f\"Secado a mano: {self.secado_a_mano}\")\n        print(f\"Encerado: {self.encerado}\")\n        print(\"Fase: \", end=\"\")\n        self.imprimir_fase()\n        print(\"\\n----------------------------------------\")\n\n</code></pre> <p>Este m\u00e9todo ejecutar_y_obtener_fases Se invoca junto a un par\u00e1metro num\u00e9rico y 3 par\u00e1metros adicionales referentes a prelavado, secado y encerado. Imprime una serie de sentencias en las que se informa del estado de lavado al usuario. Ejecutando un ciclo completo y devolviendo un array de en lista de fases visitadas.</p> <pre><code>\n    def ejecutar_y_obtener_fases(self, prelavado, secado, encerado):\n        self.lavadero.hacerLavado(prelavado, secado, encerado)\n        fases_visitadas = [self.lavadero.fase]\n\n        while self.lavadero.ocupado:\n            # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error\n            if len(fases_visitadas) &gt; 15:\n                raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\")\n            self.lavadero.avanzarFase()\n            fases_visitadas.append(self.lavadero.fase)\n\n        return fases_visitadas\n\n</code></pre>"},{"location":"Pruebas/","title":"Pruebas","text":"<p>En este apartado vamos a realizar un an\u00e1lisis l\u00f3gico del programa con base en una serie de pruebas partiendo de las siguientes premisas:</p> <ol> <li> <p>Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false.</p> </li> <li> <p>Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError.</p> </li> <li> <p>Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac.</p> </li> <li> <p>Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac.</p> </li> <li> <p>Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac.</p> </li> <li> <p>Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0.</p> </li> <li> <p>Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0.12.</p> </li> <li> <p>Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano y secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 0.</p> </li> <li> <p>Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0.</p> </li> </ol>"},{"location":"Pruebas/#creacion-de-los-tests","title":"Creaci\u00f3n de los tests","text":"<p>Para ello completaremos nuestro archivo de tests siguiendo las consignas superiores. </p> <p>Es importante declarar el tipo de test y vincular bien este fichero para que no tengamos problemas a la hora de correr los tests.</p> <pre><code>import unittest\nfrom src.lavadero import Lavadero\n\n\nclass TestLavadero(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Prepara una nueva instancia de Lavadero antes de cada prueba.\"\"\"\n        self.lavadero = Lavadero()\n\n    # ----------------------------------------------------------------------\n    # Test 4 del enunciado (reseteo)\n    # ----------------------------------------------------------------------\n    def test_reseteo_estado_con_terminar(self):\n        \"\"\"Test 4 extra: Verifica que terminar() resetea flags y fase pero mantiene ingresos.\"\"\"\n        # Iniciar un lavado cualquiera\n        self.lavadero.hacerLavado(True, True, True)\n        # Avanzar al menos una fase para que cobre\n        self.lavadero.avanzarFase()\n        self.assertTrue(self.lavadero.ingresos &gt; 0)\n\n        # Terminar manualmente\n        self.lavadero.terminar()\n\n        self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO)\n        self.assertFalse(self.lavadero.ocupado)\n        self.assertFalse(self.lavadero.prelavado_a_mano)\n        self.assertFalse(self.lavadero.secado_a_mano)\n        self.assertFalse(self.lavadero.encerado)\n        # Los ingresos se mantienen\n        self.assertTrue(self.lavadero.ingresos &gt; 0)\n\n    # ----------------------------------------------------------------------\n    # TESTS 1\u20133: reglas b\u00e1sicas / excepciones\n    # ----------------------------------------------------------------------\n    def test1_estado_inicial_correcto(self):\n        \"\"\"Test 1: estado inicial sin ingresos, fase 0, no ocupado y opciones a False.\"\"\"\n        self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO)\n        self.assertEqual(self.lavadero.ingresos, 0.0)\n        self.assertFalse(self.lavadero.ocupado)\n        self.assertFalse(self.lavadero.prelavado_a_mano)\n        self.assertFalse(self.lavadero.secado_a_mano)\n        self.assertFalse(self.lavadero.encerado)\n\n    def test2_excepcion_encerado_sin_secado(self):\n        \"\"\"Test 2: encerar sin secado a mano lanza ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            self.lavadero.hacerLavado(prelavado_a_mano=False,\n                                    secado_a_mano=False,\n                                    encerado=True)\n\n    def test3_excepcion_lavado_mientras_ocupado(self):\n        \"\"\"Test 3: iniciar un segundo lavado mientras est\u00e1 ocupado lanza RuntimeError.\"\"\"\n        self.lavadero.hacerLavado(False, False, False)\n        # Sin terminar el primero, intentamos iniciar otro\n        with self.assertRaises(RuntimeError):\n            self.lavadero.hacerLavado(True, False, False)\n\n    # ----------------------------------------------------------------------\n    # TESTS 4\u20138: ingresos seg\u00fan combinaci\u00f3n de opciones\n    # (usamos una nueva instancia por test gracias a setUp)\n    # ----------------------------------------------------------------------\n    def _cobrar_lavado(self, prelavado, secado, encerado):\n        \"\"\"Helper: inicia un lavado con opciones y avanza una fase para que cobre.\"\"\"\n        self.lavadero.hacerLavado(prelavado, secado, encerado)\n        ingresos_antes = self.lavadero.ingresos\n        self.lavadero.avanzarFase()  # 0 -&gt; 1 y llama a _cobrar()\n        ingresos_despues = self.lavadero.ingresos\n        return round(ingresos_despues - ingresos_antes, 2)\n\n    def test4_ingresos_prelavado(self):\n        \"\"\"Test 4 consigna: con prelavado a mano los ingresos son 6.50\u20ac.\"\"\"\n        coste = self._cobrar_lavado(prelavado=True, secado=False, encerado=False)\n        self.assertEqual(coste, 6.50)\n\n    def test5_ingresos_secado_mano(self):\n        \"\"\"Test 5: con secado a mano los ingresos son 6.00\u20ac.\"\"\"\n        coste = self._cobrar_lavado(prelavado=False, secado=True, encerado=False)\n        self.assertEqual(coste, 6.00)\n\n    def test6_ingresos_secado_y_encerado(self):\n        \"\"\"Test 6: con secado a mano y encerado los ingresos son 7.20\u20ac.\"\"\"\n        coste = self._cobrar_lavado(prelavado=False, secado=True, encerado=True)\n        self.assertEqual(coste, 7.20)\n\n    def test7_ingresos_prelavado_y_secado(self):\n        \"\"\"Test 7: con prelavado y secado a mano los ingresos son 7.50\u20ac.\"\"\"\n        coste = self._cobrar_lavado(prelavado=True, secado=True, encerado=False)\n        self.assertEqual(coste, 7.50)\n\n    def test8_ingresos_completo_con_todo(self):\n        \"\"\"Test 8: con prelavado, secado a mano y encerado los ingresos son 8.70\u20ac.\"\"\"\n        coste = self._cobrar_lavado(prelavado=True, secado=True, encerado=True)\n        self.assertEqual(coste, 8.70)\n\n    # ----------------------------------------------------------------------\n    # TESTS 9\u201314: flujo de fases usando ejecutar_y_obtener_fases\n    # ----------------------------------------------------------------------\n    def test9_flujo_rapido_sin_extras(self):\n        \"\"\"Test 9: fases 0,1,3,4,5,6,0 sin extras.\"\"\"\n        fases_esperadas = [0, 1, 3, 4, 5, 6, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=False, secado=False, encerado=False\n        )\n        self.assertEqual(\n            fases_esperadas, fases_obtenidas,\n            f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\"\n        )\n\n    def test10_flujo_con_prelavado(self):\n        \"\"\"Test 10: con prelavado fases 0,1,2,3,4,5,6,0.\"\"\"\n        fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=True, secado=False, encerado=False\n        )\n        self.assertEqual(fases_esperadas, fases_obtenidas)\n\n    def test11_flujo_con_secado_mano(self):\n        \"\"\"Test 11: con secado a mano fases 0,1,3,4,5,7,0.\"\"\"\n        fases_esperadas = [0, 1, 3, 4, 5, 7, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=False, secado=True, encerado=False\n        )\n        self.assertEqual(fases_esperadas, fases_obtenidas)\n\n    def test12_flujo_secado_y_encerado(self):\n        \"\"\"Test 12: con secado a mano y encerado fases 0,1,3,4,5,7,8,0.\"\"\"\n        fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=False, secado=True, encerado=True\n        )\n        self.assertEqual(fases_esperadas, fases_obtenidas)\n\n    def test13_flujo_prelavado_y_secado(self):\n        \"\"\"Test 13: con prelavado y secado fases 0,1,2,3,4,5,7,0.\"\"\"\n        fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=True, secado=True, encerado=False\n        )\n        self.assertEqual(fases_esperadas, fases_obtenidas)\n\n    def test14_flujo_completo_con_todo(self):\n        \"\"\"Test 14: con prelavado, secado y encerado fases 0,1,2,3,4,5,7,8,0.\"\"\"\n        fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0]\n        fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(\n            prelavado=True, secado=True, encerado=True\n        )\n        self.assertEqual(fases_esperadas, fases_obtenidas)\n\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre>"},{"location":"Pruebas/#ejecutamos-los-tests","title":"Ejecutamos los tests.","text":"<p>Antes de nada, es necesario instalar un int\u00e9rprete de Python, para ello descargaremos una versi\u00f3n estable en nuestra m\u00e1quina y activaremos la opci\u00f3n de <code>Path</code>.</p> <p></p> <p>Despu\u00e9s de a\u00f1adir el int\u00e9rprete, emplearemos el paquete de plugins oficial de python para VS-Code centrando nuestra atenci\u00f3n en el icono del matraz.</p> <p>Pasos de configuraci\u00f3n Icono Matraz -&gt; tipo de test (unittest) -&gt;  directorio de pruebas (tests) -&gt; terminaci\u00f3n (test_*.py)</p> <p>Se nos generar\u00e1 una carpeta <code>.vscode</code> donde se guardar\u00e1 la configuraci\u00f3n de b\u00fasqueda de pruebas y otro directorio <code>_pycashe_</code> dentro de <code>tests</code> donde se gurdar\u00e1n las pruebas. Tras ello, nos aparecer\u00e1n las pruebas en el listado del apartado pruebas.</p> <p></p> <p>Al darle al Play se nos ejecutar\u00e1n todas las pruebas, mostrando en pantalla el resultado de estas, en nuestro caso vemos que han fallado las consignas, 5, 7, 9, 10, 11, 12, 13 y 14.</p> <p></p> <p>Revisaremos cada una de ellas para sanear los resultados.</p>"},{"location":"Pruebas/#ajustes-de-codigo","title":"Ajustes de c\u00f3digo.","text":"<p>Abordaremos cada caso por separado y siguiendo el mismo formato.</p>"},{"location":"Pruebas/#fallo-de-prueba-5-la-solucion-arregla-la-7","title":"Fallo de prueba 5 (la soluci\u00f3n arregla la 7)","text":"<p>Diagn\u00f3stico: Fallo de c\u00e1lculo imprevisto. (6.20 != 6.00) </p> <p>SOLUCI\u00d3N: </p> <p>Seg\u00fan las intenciones del comentario de deste m\u00e9todo de cobro, el precio de secado a mano y encerado est\u00e1 invertido, lo que causa este problema de c\u00e1lculo en la combinaci\u00f3 de la prueba 5 y 7.</p>"},{"location":"Pruebas/#fallo-de-prueba-9-la-solucion-arregla-la-10-11-y-13","title":"Fallo de prueba 9 (la soluci\u00f3n arregla la 10 ,11 y 13)","text":"<p>Diagn\u00f3stico: M\u00e9todo inexistente. </p> <p>SOLUCI\u00d3N: </p> <p>El m\u00e9todo estaba fuera de la clase,la soluci\u00f3n es tabular el m\u00e9todo para incluirlo en la clase y un error ortogr\u00e1fico en un par\u00e1metro. </p> <p>_hacer_lavado(...) -&gt; hacerLavado(...)</p> <p>Tras corregir este error, nos topamos con otro contiguo...</p> <p>Diagn\u00f3stico: Obtenci\u00f3n de secuencias de fase dispareja.</p> <p></p> <p>SOLUCI\u00d3N: </p> <p>En el m\u00e9todo de avanzar fase, debemos de intercambiar los valores de intercambio de fase en el if-else al acabar la fase de rodillos(5), en el caso de que secado a mano sea true, la fase siguiente ha de ser secado a mano(6), si no secado autom\u00e1tico(7).</p>"},{"location":"Pruebas/#fallo-de-prueba-12-la-solucion-arregla-la-14","title":"Fallo de prueba 12 (la soluci\u00f3n arregla la 14)","text":"<p>Diagn\u00f3stico: Lista obtenida no coincidente con al esperada. (Falta la fase 8) </p> <p>SOLUCI\u00d3N: </p> <p>El if que detecta si la fase es secado a mano(7) hace que finalice las fases, en su lugar, debe de cambiar la fase a la de encerado(8).</p> <p>Cambiar el contenido del if de: self.terminar() -&gt; self.__fase = self.FASE_ENCERADO.</p>"},{"location":"Pruebas/#resultado-final","title":"RESULTADO FINAL:","text":"<p>Finalmente todas las pruebas quedan superadas.</p>"}]}